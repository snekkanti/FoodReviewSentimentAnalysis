{
    "collab_server" : "",
    "contents" : "packages <- c(\"readr\", \"tm\", \"ztable\", \"wordcloud\", \"png\", \"parallel\", \"plot3D\", \"textcat\", \"tidytext\", \"RTextTools\")\nif (length(setdiff(packages, rownames(installed.packages()))) > 0) {\n  install.packages(setdiff(packages, rownames(installed.packages())))  \n}\n\n\nlibrary(data.table)\nlibrary(readr)\nlibrary(tm)\nlibrary(wordcloud)\nlibrary(png)\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(plot3D)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(magrittr)\nlibrary(textcat)\nlibrary(tidytext)\nlibrary(RTextTools)\nlibrary(ztable)\nsetwd(\"~/Box Sync/FoodReviews\")\ncon = dbConnect(SQLite(), dbname=\"database.sqlite\")\n# get a list of all tables\nalltables = dbListTables(con)\n# get the Reviews as a data.frame\nallreviews = dbGetQuery( con,'select * from Reviews LIMIT 10000' )\n# allreviews <- read.csv(\"/Users/shnekkanti/Box Sync/AmazonFoodReviewsSubset.csv\")\nallreviews$ProductId <- NULL\nallreviews$UserId <- NULL\nallreviews$ProfileName <- NULL\nallreviews$review.length <- nchar(allreviews$Text)\n\n# Loading the first sentiment score lexicon\nAFINN <- sentiments %>%\n  filter(lexicon == \"AFINN\") %>%\n  select(word, afinn_score = score)\n## Print in table format to help understand the words and scores associated.  \nztab <- ztable(as.data.frame(head(AFINN, 10)), digits = 1\n               , caption = 'AFINN Score')\n# Loading the second sentiment score lexicon\nBing <- sentiments %>%\n  filter(lexicon == \"bing\") %>%\n  select(word, bing_sentiment = sentiment)\n\n## Print in table format to help understand the words and scores associated.  \nztab <- ztable(as.data.frame(head(Bing, 10)), digits = 1\n               , caption = 'Bing Score')\n\n# \"tidying\" up the data (1 word per row) and adding the sentiment scores for each word\nfood_review_words <- allreviews %>%\n  unnest_tokens(word, Text) %>%\n  select(-c(Summary, HelpfulnessNumerator,HelpfulnessDenominator)) %>%\n  left_join(AFINN, by = \"word\") %>%\n  left_join(Bing, by = \"word\")\n\n#Filter the data to display rows with proper score. Just for viewing purpose\nfilteredData <- subset(food_review_words, bing_sentiment == \"positive\" | bing_sentiment == \"negative\")\nztab <- ztable(as.data.frame(head(filteredData , 10)), digits = 1\n               , caption = 'Sentiment score for each word')\nztab\n\n# Grouping by mean for observation \n  review_mean_sentiment <- food_review_words %>%\n    group_by(Id, Score) %>%\n    summarize(mean_sentiment = mean(afinn_score, na.rm = TRUE))\n  # Plotting the result\n  theme_set(theme_bw())\n  ggplot(review_mean_sentiment, aes(Score, mean_sentiment, group = Score)) + \n    geom_boxplot() +\n    ylab(\"Average sentiment score\")\n\n\n\n# Transferring the results to the new dataset\nreview_mean_sentiment <- review_mean_sentiment %>%\n  select(-Score) %>%\n  data.table()\ncleaned_food_reviews <- allreviews %>%\n  left_join(review_mean_sentiment, by = \"Id\")\n\n\n# Same as previous, but with the median\nreview_median_sentiment <- food_review_words %>%\n  group_by(Id, Score) %>%\n  summarize(median_sentiment = median(afinn_score, na.rm = TRUE))\ntheme_set(theme_bw())\nggplot(review_median_sentiment, aes(Score, median_sentiment, group = Score)) +\n  geom_boxplot() +\n  ylab(\"Median sentiment score\")\n\n# Transferring the results to our new dataset\nreview_median_sentiment <- review_median_sentiment %>%\n  select(-Score) %>%\n  data.table()\ncleaned_food_reviews <- cleaned_food_reviews %>%\n  left_join(review_median_sentiment, by = \"Id\")\n\n\n# Counting the number of negative words per review according to AFINN lexicon\nreview_count_afinn_negative <- food_review_words %>%\n  filter(afinn_score < 0) %>%\n  group_by(Id, Score) %>%\n  summarize(count_afinn_negative = n())\n# Transferring the results to our dataset\nreview_count_afinn_negative <- review_count_afinn_negative %>%\n  select(-Score) %>%\n  data.table()\ncleaned_food_reviews <- cleaned_food_reviews %>%\n  left_join(review_count_afinn_negative, by = \"Id\")\n\n# Counting the number of positive words per review according to AFINN lexicon\nreview_count_afinn_positive <- food_review_words %>%\n  filter(afinn_score > 0) %>%\n  group_by(Id, Score) %>%\n  summarize(count_afinn_positive = n())\n# Transferring the results to our dataset\nreview_count_afinn_positive <- review_count_afinn_positive %>%\n  select(-Score) %>%\n  data.table()\ncleaned_food_reviews <- cleaned_food_reviews %>%\n  left_join(review_count_afinn_positive, by = \"Id\")\n\n\n\n\n# Counting the number of negative words per review according to BING lexicon\nreview_count_bing_negative <- food_review_words %>%\n  filter(bing_sentiment == \"negative\" ) %>%\n  group_by(Id, Score) %>%\n  summarize(count_bing_negative = n())\n# Transferring the results to our dataset\nreview_count_bing_negative <- review_count_bing_negative %>%\n  select(-Score) %>%\n  data.table()\ncleaned_food_reviews <- cleaned_food_reviews %>%\n  left_join(review_count_bing_negative, by = \"Id\")\n\n# Counting the number of positive words per review according to BING lexicon\nreview_count_bing_positive <- food_review_words %>%\n  filter(bing_sentiment == \"positive\") %>%\n  group_by(Id, Score) %>%\n  summarize(count_bing_positive = n())\n# Transferring the results to our dataset\nreview_count_bing_positive <- review_count_bing_positive %>%\n  select(-Score) %>%\n  data.table()\ncleaned_food_reviews <- cleaned_food_reviews %>%\n  left_join(review_count_bing_positive, by = \"Id\")\n\n# Writing the data to file for future analyses\nwrite.csv(cleaned_food_reviews, \"FoodReviewsCleanData.csv\", row.names = FALSE)\n\n",
    "created" : 1505943968632.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "534717077",
    "id" : "10E28FF3",
    "lastKnownWriteTime" : 1505947544,
    "last_content_update" : 1505947544212,
    "path" : "~/Box Sync/FoodReviews/AmazonFoodReviewsUpdate7.R",
    "project_path" : "AmazonFoodReviewsUpdate7.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}